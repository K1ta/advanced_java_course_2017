package edu.technopolis.advanced.boatswain;

import java.io.IOException;
import java.util.Objects;
import java.util.Properties;
import java.net.URLEncoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.technopolis.advanced.boatswain.incoming.request.Message;
import edu.technopolis.advanced.boatswain.incoming.request.MessageNotification;
import edu.technopolis.advanced.boatswain.request.GetSubscriptionsRequest;
import edu.technopolis.advanced.boatswain.request.SearchRequest;
import edu.technopolis.advanced.boatswain.request.SendMessagePayload;
import edu.technopolis.advanced.boatswain.request.SendMessageRequest;
import edu.technopolis.advanced.boatswain.request.SendRecipient;
import edu.technopolis.advanced.boatswain.request.SubscribePayload;
import edu.technopolis.advanced.boatswain.request.SubscribeRequest;
import edu.technopolis.advanced.boatswain.response.GetSubscriptionsResponse;
import edu.technopolis.advanced.boatswain.response.SearchResponse;
import edu.technopolis.advanced.boatswain.response.SendMessageResponse;
import edu.technopolis.advanced.boatswain.response.SubscribeResponse;
import edu.technopolis.advanced.boatswain.response.Subscription;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class BoatswainBot {
    private static final Logger log = LoggerFactory.getLogger(BoatswainBot.class);

    public static void main(String[] args) {
        Properties props = new Properties();
        log.info("Reading application properties...");
        try {
            props.load(BoatswainBot.class.getResourceAsStream("/application.properties"));
        } catch (IOException e) {
            log.error("Failed to read application properties. Terminating application...");
            System.exit(1);
        }
        ApiClient okClient = createClient(props);
        try {
            GetSubscriptionsResponse response = okClient.get(
                    new GetSubscriptionsRequest(props.getProperty("ok.api.endpoint.subscriptions")), GetSubscriptionsResponse.class);
            String botEndpoint = props.getProperty("bot.message.endpoint");
            log.info("Checking that bot is subscribed to messages...");
            if (checkSubscribed(botEndpoint, response)) {
                log.info("Subscription exists");
            } else {
                log.info("Subscription does not exist. Making a subscription...");
                subscribe(okClient, props, botEndpoint);
                log.info("Subscription is ok");
            }
            log.info("Creating endpoint...");
            BotServer server = createServer(okClient, props);
            log.info("Server created. Waiting for incoming connections...");
            addShutDownHooks(server, okClient);
        } catch (Exception e) {
            log.error("Unexpected failure", e);
            closeClient(okClient);
            System.exit(1);
        }
    }

    private static void addShutDownHooks(BotServer server, ApiClient okClient) {
        Runtime
                .getRuntime()
                .addShutdownHook(new Thread(() -> {
                    closeClient(okClient);
                    server.stop();
                }));
    }

    private static void closeClient(ApiClient client) {
        if (client != null) {
            try {
                client.close();
            } catch (IOException ce) {
                log.error("Failed to close client", ce);
            }
        }
    }

    private static void subscribe(ApiClient client, Properties props, String botEndpoint) throws IOException {
        SubscribeRequest req = new SubscribeRequest(props.getProperty("ok.api.endpoint.subscribe"),
                new SubscribePayload(botEndpoint));
        SubscribeResponse post = client.post(req, SubscribeResponse.class);
        if (!post.isSuccess()) {
            throw new IllegalStateException("Failed to subscribe bot to messages");
        }
    }

    private static boolean checkSubscribed(String botEndpoint, GetSubscriptionsResponse subscriptionsResponse) {
        if (subscriptionsResponse.getSubscriptions() == null || subscriptionsResponse.getSubscriptions().isEmpty()) {
            return false;
        }

        for (Subscription subscription : subscriptionsResponse.getSubscriptions()) {
            if (Objects.equals(subscription.getUrl(), botEndpoint)) {
                return true;
            }
        }
        return false;
    }

    private static ApiClient createClient(Properties props) {
        String schema = props.getProperty("ok.api.schema", "https");
        String host = props.getProperty("ok.api.host");
        String tokenParamName = props.getProperty("ok.api.param.token");
        String token = props.getProperty("ok.api.access_token");
        return new ApiClient(schema, host, tokenParamName + '=' + token);
    }

    private static BotServer createServer(ApiClient okClient, Properties props) throws IOException {
        try {
            return new BotServer(
                    props.getProperty("bot.message.local.endpoint"),
                    new MessageSender(okClient, props)::send
            ).start();
        } catch (IOException e) {
            log.error("Failed to initialize http server on port 80");
            throw e;
        }
    }

    private static class MessageSender {

        private final ApiClient client;
        private final String sendEndpoint;
        ApiClient lurkClient;
        private final String lurkEndPoint;
        String lurkHost;

        MessageSender(ApiClient okClient, Properties props) {
            this.client = okClient;
            this.sendEndpoint = props.getProperty("ok.api.endpoint.send");
            this.lurkEndPoint = props.getProperty("lurk.endpoint.search");
            this.lurkHost = props.getProperty("lurk.host");

            lurkClient=new ApiClient("https",
                    lurkEndPoint,null);
        }

        boolean send(MessageNotification notif) {


            try
            {
                SearchRequest searchRequest = new SearchRequest(
                        URLEncoder.encode(notif.getMessage().getText(), "UTF-8"));
               SearchResponse searchResponse = lurkClient.get(searchRequest, SearchResponse.class);
               StringBuilder ans = new StringBuilder();

               if(searchResponse.getQuery().getSearch().size()==0){
                   ans.append("We were unable to find anything at your request :(\n");
               }else {
                   for (int i = 0; i < searchResponse.getQuery().getSearch().size(); i++) {
                       ans.append("(" + searchResponse.getQuery().getSearch().get(i).getTitle() + ") "
                               + lurkHost + URLEncoder.encode(searchResponse.getQuery().getSearch().get(i).getTitle(),
                               "UTF-8") + "\n");
                   }
               }

                SendMessageRequest req = new SendMessageRequest(sendEndpoint, notif.getRecipient().getChatId())
                        .setPayload(
                                new SendMessagePayload(
                                        new SendRecipient(notif.getSender().getUserId()),
                                        new Message(ans.toString())
                                )
                        );

                try {
                    return client.post(req, SendMessageResponse.class).getMessageId() != null;
                } catch (IOException e) {
                    log.error("Failed to send message", e);
                    return false;
                }

            } catch (IOException e)
            {
                log.error("error lurk get");
                return false;
            }
        }
    }

}
